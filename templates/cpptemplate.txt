#### main

/*

This file was generated by MCWRAP, author: Jeremy Magland
You should not edit this file.
See https://github.com/magland/mcwrap

*/

#include "mex.h"

///
#include "../$code_basename$.h"

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{
    /////////////////////////////////////////
    //check the number of inputs/outputs
    if (nrhs!=$num_inputs$) {
        mexPrintf("Incorrect number of inputs.\n");
        return;
    }
    if (nlhs>$num_outputs$) {
        mexPrintf("Incorrect number of outputs.\n");
        return;
    }
   
    /////////////////////////////////////////
    ///setup the inputs
    ///
    %foreach input
        %if $is_array$=1
            ^template setup_input_array$underscore_complex$
        %end if $is_array$=1
        %if $is_array$=0
            ^template setup_input_scalar
        %end if $is_array$=0
    %end foreach input
    
    /////////////////////////////////////////
    ///setup the outputs
    ///
    %foreach output
        %if $is_array$=1
            ^template setup_output_array$underscore_complex$
        %end if $is_array$=1
        %if $is_array$=0
            ^template setup_output_scalar
        %end if $is_array$=0
    %end foreach output
    
    /////////////////////////////////////////
    ///run the actual function
    $function_name$($arguments$);
 
    /////////////////////////////////////////
    ///free the inputs
    %foreach input
        %if $is_array$=1
            ^template free_input_array
        %end if $is_array$=1
    %end foreach input
   
    /////////////////////////////////////////
    ///set and free the outputs
    ///
    %foreach output
        %if $is_array$=1
            ^template set_output_array$underscore_complex$
        %end if $is_array$=1
        %if $is_array$=0
            ^template set_output_scalar
        %end if $is_array$=0
    %end foreach output
    
    /////////////////////////////////////////
    ///we are done
}

#### setup_input_array

    double *p_input_$pname$=mxGetPr(prhs[$pindex$-1]);
    $dtype$ *input_$pname$=($dtype$ *)malloc(sizeof($dtype$)*($total_size$));
    for (int i=0; i<($total_size$); i++) {
        input_$pname$[i]=p_input_$pname$[i];
    }

#### setup_input_array_complex

    double *p_input_$pname$_re=mxGetPr(prhs[$pindex$-1]);
    double *p_input_$pname$_im=mxGetPi(prhs[$pindex$-1]);
    $dtype$ *input_$pname$=($dtype$ *)malloc(sizeof($dtype$)*($total_size$)*2);
    for (int i=0; i<($total_size$); i++) {
        input_$pname$[i*2]=p_input_$pname$_re[i];
        input_$pname$[i*2+1]=p_input_$pname$_im[i];
    }

#### setup_input_scalar

    $dtype$ input_$pname$=mxGetScalar(prhs[$pindex$-1]);

#### setup_output_array

    plhs[$pindex$-1]=mxCreateDoubleMatrix($dimensions$,mxREAL);
    double *p_output_$pname$=mxGetPr(plhs[$pindex$-1]);
    $dtype$ *output_$pname$=($dtype$ *)malloc(sizeof($dtype$)*($total_size$));

#### setup_output_array_complex

    plhs[$pindex$-1]=mxCreateDoubleMatrix($dimensions$,mxCOMPLEX);
    double *p_output_$pname$_re=mxGetPr(plhs[$pindex$-1]);
    double *p_output_$pname$_im=mxGetPi(plhs[$pindex$-1]);
    $dtype$ *output_$pname$=($dtype$ *)malloc(sizeof($dtype$)*($total_size$)*2);

#### setup_output_scalar

    //scalar outputs not yet supported

#### free_input_array

    free(input_$pname$);

#### set_output_array

    for (int i=0; i<($total_size$); i++) {
        p_output_$pname$[i]=output_$pname$[i];
    }
    free(output_$pname$);    

#### set_output_array_complex

    for (int i=0; i<($total_size$); i++) {
        p_output_$pname$_re[i]=output_$pname$[i*2];
        p_output_$pname$_im[i]=output_$pname$[i*2+1];
    }
    free(output_$pname$);

#### set_output_scalar

    //scalar outputs not yet supported

#### end