#### main

/*
*
* This file was auto-generated by MCWRAP
* https://github.com/magland/mcwrap
*
* You should not edit this file.
* You might not even want to read it.
* 
*/ 

#include "mex.h"

!====================================================================
!====================================================================

void mexFunction(int nlhs, mxArray *plhs[], int nrhs, const mxArray *prhs[])
{


////////////////////////////////////////
//     Declare inputs:
@foreach input
    @if $ptype$=int
        ^template fdeclare_input_int
    @end if $ptype$=int
    @if $ptype$=double
        ^template fdeclare_input_double
    @end if $ptype$=double
    @if $ptype$=double*
        ^template fdeclare_input_double_array$underscore_complex$
    @end if $ptype$=double*
@end foreach input

//     Declare outputs:
@foreach output
    @if $ptype$=int
        ^template fdeclare_output_int
    @end if $ptype$=int
    @if $ptype$=double
        ^template fdeclare_output_double
    @end if $ptype$=double
    @if $ptype$=double*
        ^template fdeclare_output_double_array$underscore_complex$
    @end if $ptype$=double*
    @if $ptype$=int*
        ^template fdeclare_output_int_array
    @end if $ptype$=int*
@end foreach output

//     Declare set inputs:
@foreach set_input
    @if $ptype$=int
        ^template fdeclare_set_input_int
    @end if $ptype$=int
    @if $ptype$=double
        ^template fdeclare_set_input_double
    @end if $ptype$=double
@end foreach set_input

      //call mexPrintf("test A\n");
//   Check the number of inputs/outputs
      if (nlhs==0) nlhs=1
      if (nrhs!=$num_inputs$)
         mexErrMsgTxt("Incorrect number of inputs"); 
      elseif (nlhs>$num_outputs$)
         mexErrMsgTxt ("Too many outputs.");
      endif


      // mexPrintf("test A.2\n");
//    Setup the set inputs
@foreach set_input
    @if $ptype$=int
        ^template fsetup_set_input_int
    @end if $ptype$=int
    @if $ptype$=double
        ^template fsetup_set_input_double
    @end if $ptype$=double
@end foreach set_input

      //mexPrintf("test B\n");
//    Setup the inputs
@foreach input
    @if $ptype$=int
        ^template fsetup_input_int
    @end if $ptype$=int
    @if $ptype$=double
        ^template fsetup_input_double
    @end if $ptype$=double
    @if $ptype$=double*
        ^template fsetup_input_double_array$underscore_complex$
    @end if $ptype$=double*
    @if $ptype$=int*
        ^template fsetup_input_int_array
    @end if $ptype$=int*
@end foreach input
    
      //mexPrintf("test C\n");
//    Setup the outputs
@foreach output
    @if $ptype$=int
        ^template fsetup_output_int
    @end if $ptype$=int
    @if $ptype$=double
        ^template fsetup_output_double
    @end if $ptype$=double
    @if $ptype$=double*
        ^template fsetup_output_double_array$underscore_complex$
    @end if $ptype$=double*
    @if $ptype$=int*
        ^template fsetup_output_int_array
    @end if $ptype$=int*
@end foreach output

    
      //mexPrintf("test D\n");
//    Run the subroutine
        $function_name$(
$arguments$
        );
   
      //mexPrintf("test E\n");
//    Free the inputs
@foreach input
    @if $ptype$=double*
        ^template ffree_input_double_array$underscore_complex$
    @end if $ptype$=double*
    @if $ptype$=int*
        ^template ffree_input_int_array
    @end if $ptype$=int*
@end foreach input

      //mexPrintf("test F\n");
//    Set the outputs
@foreach output
    @if $ptype$=int
        ^template fset_output_int
    @end if $ptype$=int
    @if $ptype$=double
        ^template fset_output_double
    @end if $ptype$=double
    @if $ptype$=double*
        ^template fset_output_double_array$underscore_complex$
    @end if $ptype$=double*
    @if $ptype$=int*
        ^template fset_output_int_array
    @end if $ptype$=int*
@end foreach output

      //mexPrintf("test G\n");

/**** We are done *******/*

        return 0;
}

int mcwrap_size(mwPointer X,int j) {
    mwSize numdims=mxGetNumberOfDimensions(X);
    if ((j-1<0)||(j-1>=numdims)) return 1;
    int dims[100];
    mxCopyPtrToInteger(mxGetDimensions(X),dims,numdims);
    return dims[j-1];
}

#### fdeclare_set_input_int

        //$pname$
        int input_$pname$;

#### fdeclare_set_input_double

        //$pname$
        double input_$pname$;


#### fdeclare_input_double

        //$pname$
        mwPointer p_input_$pname$
        double input_$pname$

#### fdeclare_input_double_array

        //$pname$
        mwPointer p_input_$pname$
        double *input_$pname$;

#### fdeclare_input_double_array_complex

        //$pname$
        mwPointer p_input_$pname$_re;
        mwPointer p_input_$pname$_im;
        double *input_$pname$;
        double *input_$pname$_re;
        double *input_$pname$_im;

#### fdeclare_input_int_array

        //$pname$
        mwPointer p_input_$pname$;
        int *input_$pname$;
        double *input_$pname$_double;

#### fdeclare_input_int

        //$pname$
        mwPointer p_input_$pname$;
        int input_$pname$;
        double input_$pname$_double;

#### fdeclare_output_double

        //$pname$
//CC Scalar output not yet supported!

#### fdeclare_output_double_array

        //$pname$
        mwPointer p_output_$pname$;
        double *output_$pname$;

#### fdeclare_output_double_array_complex

        //$pname$
        mwPointer p_output_$pname$_re;
        mwPointer p_output_$pname$_im;
        double *output_$pname$;
        double *output_$pname$_re;
        double *output_$pname$_im;

#### fdeclare_output_int_array

        //$pname$
        mwPointer p_output_$pname$;
        int *output_$pname$;
        double *output_$pname$_double;

#### fdeclare_output_int

        //$pname$
//CC Scalar output not yet supported!

#### ffree_input_double_array

        //$pname$
        free(input_$pname$);

#### ffree_input_double_array_complex

        //$pname$
        free(input_$pname$);
        free(input_$pname$_re);
        free(input_$pname$_im);

#### ffree_input_int_array

        //!$pname$
        free(input_$pname$);
        free(input_$pname$_double);

#### fset_output_double

        //$pname$
//CC Scalar outputs not yet supported

#### fset_output_double_array

        //$pname$
        if ($pindex$<=nlhs) {
            mxCopyReal8ToPtr(output_$pname$,p_output_$pname$,(int)($total_size$));
        }
        free(output_$pname$);

#### fset_output_double_array_complex

        //$pname$
        if ($pindex$<=nlhs) {
            for (long i=0; i<$total_size; i++) {
                output_$pname$_re[ii]=output_$pname$[ii*2];
                output_$pname$_im[ii]=output_$pname$[ii*2+1];
            }
            mxCopyReal8ToPtr(output_$pname$_re,p_output_$pname$_re,(int)($total_size$));
            mxCopyReal8ToPtr(output_$pname$_im,p_output_$pname$_im,(int)($total_size$));
        }
        free(output_$pname$);
        free(output_$pname$_re);
        free(output_$pname$_im);

#### fset_output_int_array

        //$pname$
        if ($pindex$<=nlhs) {
            for (long i=0; i<$total_size; i++) {
                output_$pname$_double[ii]=output_$pname$[ii];
            }
            mxCopyReal8ToPtr(output_$pname$_double,p_output_$pname$,(int)($total_size$));
        }
        free(output_$pname$);
        free(output_$pname$_double);

#### fset_output_int

//CC Scalar outputs not yet supported

#### fsetup_input_double

        //$pname$
        p_input_$pname$=mxGetPr(prhs[$pindex$-1]);
        mxCopyPtrToReal8(p_input_$pname$,input_$pname$,1);

#### fsetup_input_int

        //$pname$
        p_input_$pname$=mxGetPr(prhs[$pindex$-1]);
        mxCopyPtrToReal8(p_input_$pname$,input_$pname$_double,1);
        input_$pname$=(int)(input_$pname$_double);

#### fsetup_input_double_array

        //$pname$
        ^template fsetup_check_dimensions
        p_input_$pname$=mxGetPr(prhs[$pindex$-1]);
        input_$pname$=(double *)malloc(sizeof(double)*($total_size$));
        mxCopyPtrToReal8(p_input_$pname$,input_$pname$,(int)($total_size$));
        
#### fsetup_input_double_array_complex

        //$pname$
        ^template fsetup_check_dimensions
        p_input_$pname$_re=mxGetPr(prhs[$pindex$-1]);
        p_input_$pname$_im=mxGetPi(prhs[$pindex$-1]);
        input_$pname$=(double *)malloc(sizeof(double)*($total_size$*2));
        input_$pname$_re=(double *)malloc(sizeof(double)*($total_size$));
        input_$pname$_im=(double *)malloc(sizeof(double)*($total_size$));
        mxCopyPtrToReal8(p_input_$pname$_re,input_$pname$_re,(int)($total_size$));
        if (p_input_$pname$_im) {
            mxCopyPtrToReal8(p_input_$pname$_im,input_$pname$_im,(int)($total_size$));
        }
        for (long ii=0; ii<$total_size$; i++) {
            input_$pname$[ii*2]=input_$pname$_re[ii];
            if (p_input_$pname$_im) {
                input_$pname$[ii*2+1]=input_$pname$_im[ii];
            }
            else {
                input_$pname$[ii*2+1)=0    
            }
        }

#### fsetup_input_int_array

        //$pname$
        ^template fsetup_check_dimensions
        p_input_$pname$=mxGetPr(prhs[$pindex$-1]);
        input_$pname$=(int *)malloc(sizeof(int)*($total_size$));
        input_$pname$_double=(double *)malloc(sizeof(double)*($total_size$));
        mxCopyPtrToReal8(p_input_$pname$,input_$pname$_double,(int)($total_size$));
        for (long ii=0; ii<$total_size$; i++) {
            input_$pname$[ii]=int(input_$pname$_double[ii])
        }
        

#### fsetup_check_dimensions

        //Check that we have the correct dimensions!
        int numdims=mxGetNumberOfDimensions(prhs[$pindex$-1]);
        if (numdims!=$numdims$) {
          mexErrMsgTxt("Incorrect number of dimensions in input: $pname$");
        }
        mxCopyPtrToInteger4(mxGetDimensions(prhs[$pindex$-1]),dims,numdims);
        dims2={ $dimensions$ };
        for (long ii=0; ii<numdims; i++) {
          if (dims[ii]!=dims2[ii]) {
            mexErrMsgTxt("Incorrect size of input: $pname$");
          }
        }

#### fsetup_output_double

        //$pname$
//CC Scalar output not yet supported

#### fsetup_output_double_array

        //$pname$
        if ($pindex$<=nlhs) {
            ^template check_dimensions_valid
            plhs[$pindex$-1]=mxCreateNumericArray($numdims$,{ $dimensions$ },mxDOUBLE,mxREAL);
            p_output_$pname$=mxGetPr(plhs[$pindex$-1]);
        }
        output_$pname$=(double *)malloc(sizeof(double)*($total_size$));

#### fsetup_output_double_array_complex

        //$pname$
        if ($pindex$<=nlhs) {
            ^template check_dimensions_valid
            plhs[$pindex$-1]=mxCreateNumericArray($numdims$,{ $dimensions$ },mxDOUBLE,mxCOMPLEX);
            p_output_$pname$_re=mxGetPr(plhs[$pindex$-1]);
            p_output_$pname$_im=mxGetPi(plhs[$pindex$-1]);
        }
        output_$pname$=(double *)malloc(sizeof(double)*($total_size$)*2);
        output_$pname$_re=(double *)malloc(sizeof(double)*($total_size$));
        output_$pname$_im=(double *)malloc(sizeof(double)*($total_size$));

#### fsetup_output_int_array

        //$pname$
        if ($pindex$<=nlhs) {
            ^template check_dimensions_valid
            plhs[$pindex$-1]=mxCreateNumericArray($numdims$,{ $dimensions$ },mxDOUBLE,mxREAL);
            p_output_$pname$=mxGetPr(plhs[$pindex$-1])
        }
        output_$pname$=(int *)malloc(sizeof(int)*($total_size$));
        output_$pname$_double=(double *)malloc(sizeof(double)*($total_size$));

#### check_dimensions_valid

        if (($numdims$<1)||($numdims$>20)) {
          mexErrMsgTxt("Bad number of dimensions for my taste: $numdims$"); 
        }
        dims2={ $dimensions$ };
        for (long ii=0; ii<$numdims$; ii++) {
            if ((dims2[ii]<1)||(dims2[ii]>10000000000.0)) {
              call mexErrMsgTxt ("Bad array size for my taste: $dimensions$"); 
            }
        }
        
#### fsetup_output_int

//CC Scalar output not yet supported

#### fsetup_set_input_double

        //$pname$
        input_$pname$=$set_value$;

#### fsetup_set_input_int

        //!$pname$
        input_$pname$=(int)($set_value$);


#### end

